# 磁盘知识体系结构图

<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\磁盘知识体系结构.png" alt="磁盘知识体系结构" style="zoom:75%;" />


# 第一层次

* SSD
```
1.写入寿命有限
2.数据难以恢复
```
#### 企业级SAS硬盘(默认):
    * 企业里常见的SAS硬盘是15000转/分(这里就是主轴的转数),一般选6*300G，6*600G，`满足容量的基础上尽量保持4块磁盘以上`


#### 企业级SATA硬盘:
    * 7200-10000转/分，优点是经济实惠，容量大。
    * 常用于数据量少，数据不需要给用户提供服务;用于备份。

#### 磁盘选购小结
    ```
    1)、线上的业务，用SAS磁盘。
    2)、线下的业务，用SATA磁盘。
    3)、线上高并发、小容量的业务，SSD磁盘。
    4)、成本控制思想:根据数据的访问热度，智能分析分层存储。SATA+SSD
    ```

#### 企业案例一:
* 不要用SATA磁盘来做在线高并发服务的数据存储或数据库业务，这是血的教训。

```
某公司采用SATA做数据库的存储盘，结果导致数据库连续宕机一个月。5台SATA盘RAID5。

解决:
    重新买5台，把磁盘从SATA(RAID5)换成SAS(RAID10)。6个月内没事。
问题所在:
    1)、数据库集群，主库选择用SAS Raid10，从库SAS Raid0。
    2)、当时数据库使用的引擎是MyISAM引擎(改引擎是表锁，不适合高并发访问)，改成Innodb引擎(行锁，顾名思义更新数据只所一行)。
    !!!主数据库只能写，从数据库只能读。
```

#### 淘宝网CDN缓存对象分级存储策略案例
* 提出问题:
```
在存储数据中，18KB以下的对象数据占总数量的80%，而其存储量占总量不到40%;同时，80%经常被访问的对象所占用的存储空间不到总量的20%。
```
* 分析问题:
```
以上的问题意味着"热点数据"(即访问频次高的内容)需要更快的性能，而占的空间并不大，而"冷数据"(访问频次低的内容)所需存储量很大，对性能要求不需要高。
```

* 解决问题:
```
因此，服务器引入分层存储机制，单台服务器(实际会多台)的磁盘可由一块80GB的SSD磁盘和两块500GB的SATA盘组成。然后把"热数据"存放在SSD盘上，"冷数据"存放在SATA盘上，冷热数据可以动态调度，从而兼顾性能、容量与成本。
!!!另:分层存储调度软件由淘宝开发。
```



## 磁盘核心知识及数据读写原理
#### 磁盘相关名词说明
英文		|	汉语
------------|:------------:
Disk		|     磁盘
Head		|   磁头
Sector		  |   扇区
Track		  |   磁道
Cylinder	|	柱面
Units		|	单元块(一个柱面的大小)
Block		|	数据块
Inode		|	索引节点

#### 磁盘示意图
* <img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\磁盘盘片示意图.png" alt="磁盘盘片示意图" style="zoom:75%;" />
##### 磁道
* 磁盘上相同圆心的不同半径的同心圆轨迹，`300~1024`个磁道。
* 由外到内依次从0开始递增

##### 柱面
* 不同盘面上的半径相同的磁道组成的。

##### 扇区
* 磁道上的一段圆弧。
* 每个扇区大小为512字节。
* 主要部分是标识符。

##### 记忆要点(磁道柱面扇区)
```
1)、一块磁盘有2-14个盘片，每个盘片有两个面，没有面对应一个读写磁头，用磁头号来区分盘面，即盘面数就是磁头数，盘片数*2=磁头数（盘面数）
2)、不同盘面的磁道被划分为多个扇形区域，每个区域就是一个扇区(Sector)。
3)、同一个盘面，以盘片中心为圆心，每个不同半径的圆形轨迹就是一个磁道(Track)。
4)、不同盘面相同半径的磁道组成一个圆柱面就是柱面(Cylinder)。
5)、一个柱面包含多个磁道(这些磁道的半径相同)，一个磁道包含多个扇区。
6)、数据信息记录可表示为:某磁头，某磁道（柱面），某扇区。

```
##### 磁盘容量计算
* ==磁盘容量== =`512字节`* `每磁道扇区数` * `磁道数` * `磁头数`

#### 磁盘的读写流程
* 按柱面来读写
* <img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\磁盘读写原理图.png" alt="磁盘读写原理图" style="zoom:75%;" />

## 命令
##### 查看磁盘及对应的分区
* `fdisk -l`
##### 计算磁盘容量
* `echo 512*63*2610*255/1000000000|bc`  bc是计算的意思




<br />
<br />

# 第二层次
## RAID
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID的介绍.png" alt="磁盘读写原理图" style="zoom:75%;" />

* RAID就是磁盘阵列
#### 生产环境中常用的raid级别: ` Raid 0` `Raid 1` `Raid 5` `Raid 10`

##### 四种常用raid级别的优缺点：
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\4种raid的优缺点.png" alt="4种raid的优缺点" style="zoom:75%;" />

##### 七个raid的简单定义
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\7个raid的简单定义.png" alt="7个raid的简单定义" style="zoom:75%;" />

### RAID分为两类:
#### Ⅰ、==软RAID==：系统层面实现的，性能差。
#### Ⅱ、==硬RAID==：硬件层面实现的，性能好。
*  **==主板板载RAID==：功能弱，只支持`Raid 0`和`Raid 1`**
* **==独立RAID卡==：功能强，支持`Raid 0`、`Raid 1`、`Raid 5`、`Raid 10`。**



<br />
<br />

## LVM（Logic Volume Management）逻辑卷管理
```
它的最大用途是可以【灵活的管理磁盘的容量】，让磁盘分区可以随意放大或缩小，便于更好的应用磁盘的剩余空间，如果过于强调性能与备份，那么还是应该使用RAID功能，而不是LVM。
```
##### 不需要的理由:
* **LVM是软件层面实现的，性能太低，性能降低5-10%。**
* **买服务器插满磁盘，分区规划好，永远都不需要LVM。**



#### RAID和LVM的区别:
* **==LVM==**：灵活的管理磁盘，有一定的冗余和性能，但是很弱。
* **==RAID==**：更侧重性能和数据安全。

#### RAID最直接的好处:
```
1)、提升数据安全性。
2)、提升数据读写性能。
3)、提供更大的单一逻辑磁盘数据容量存储。
```

<br />
<br />

## 常用RAID细说
### RAID 0
##### 技术图:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID0的技术图.png" alt="RAID0的技术图" style="zoom:75%;" />

##### 优缺点:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID0的特点.png" alt="RAID0的特点" style="zoom:75%;" />

* 可以为一块盘。

##### 生产应用场景:
```
1)、负载均衡集群下面的多个相同RS节点服务器。
2)、分布式文件存储下面的主节点或CHUNK SERVER。
3)、MySQL主从复制的多个Slave服务器。
4)、对性能要求很高，对冗余要求很低的相关业务。
```

<br />

### RAID 1
```
 又名镜像，它的宗旨是最大限度的保证用户数据的可用性和可修复性。RAID 1的操作方式是把用户写入一个磁盘的数据百分之百地自动复制到另外一个磁盘上，从而实现存储双份的数据。
```

##### 技术图:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID1的技术图.png" alt="RAID1的技术图" style="zoom:75%;" />

##### 优缺点:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID1的特点.png" alt="RAID1的特点" style="zoom:75%;" />

* !!! 只能两块盘，大小可以不一致，以小容量为准。

<br />

### RAID 5
``RAID 5是一种存储性能、数据安全和存储成本兼顾的存储解决方案。``

```
RAID 5需要三块或以上的物理磁盘，可以提供热备盘实现故障的恢复;
采用【奇偶校验】，可靠性强，且只有同时损坏两块硬盘时数据才会完全损坏，只损坏一块硬盘时(不论有多少块盘)，系统会根据存储的奇偶校验位重建数据，临时提供服务;此时如果有热备盘，系统还会自动在热备盘上重建故障磁盘上的数据。
```
<br />

##### 技术图:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID5的技术图.png" alt="RAID5的技术图" style="zoom:75%;" />

* 以4块盘为例，每次写入数据，先在`前三块盘`上写入，最后一块盘上写入`前三块盘上数据的奇偶校验位`,后面再次写入的时候，在倒数第二块盘上写入`奇偶校验位`，其它三块盘写入数据。后面依次类推。

##### 优缺点:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID5的特点.png" alt="RAID5的特点" style="zoom:75%;" />

##### 3块盘优缺点详细:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID5的特点详细.png" alt="RAID5的特点详细" style="zoom:75%;" />


<br />

### RAID 10、01
##### RAID 10
```
RAID 10是先将四块硬盘在纵向上分别两两做镜像，镜像后再在横向上做皮带。即然1后0.
```
##### RAID 01
```
RAID 01是先将四块硬盘中横向上两两做皮带，然后纵向上做镜像。即先0后1
```
==!!! RAID 10和RAID 01在读写性能上没有太大的差别，从发生故障的概率上看，RAID 01是远大于RAID 10的。==

##### 优缺点:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\RAID10的特点.png" alt="RAID10的特点" style="zoom:75%;" />


#### 常用RAID对比图
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\常用RAID对比图.png" alt="常用RAID对比图" style="zoom:75%;" />


#### DELL R710 使用6块盘实践RAID制作结论
* ==Raid 0== 支持1块盘到多块盘，容量是所有盘之和。
* ==Raid 1== 只支持2块盘，容量损失一块盘。
* ==Raid 5== 最少三块盘，不管硬盘数量多少，只损失一块盘容量。
* ==Raid 6== 最少4块盘，5块盘也可以，损失2块盘，不管硬盘多少，只损失两块盘容量。
* ==Raid 10== 最少4块盘，必须偶数硬盘，不管硬盘多少，都损失一半容量，不支持虚拟磁盘。



<br />

# 第三层
## 磁盘分区
##### 回忆
```
(1)、什么是分区？
    磁盘分区就相当于给磁盘打隔断。

(2)、磁盘在Linux里的命名。
    IDE /dev/hda hdb
    SCSI sda sdb

分区数字表示: sda1 sda2 sda3

```
### 磁盘分区类型和特点:
* 主分区（primary）
    + 1. 系统中必须要存在的分区，系统盘选择主分区安装。
    + 2. 数字编号只能是1-4. sda1、sda2、sda3、sda4.
    + 3. 主分区最多四个，最少一个。

* 扩展分区（extend）
    + 1. 相当于一个独立的小磁盘。
    + 2. 有独立的分区表。
    + 3. 不能独立存在，即不能直接存放数据。
    + 4. 必须在扩展分区上建立逻辑分区才能存放数据。
    + 5. 占用主分区的编号，但要求2≤(主分区加+扩展分区)数量≤4。
    + 6. 扩展分区可以没有，有只能有一个。

* 逻辑分区（logic）
    + 1. 数字编号只能是从5开始。
    + 2. 存放于扩展分区之上。
    + 3. 存放任意普通数据

 ##### 问题:
 * 如果给一个磁盘分6个分区有哪些方案，同时写出分区/dev/sda（数字）。
 ```
 3P+1E(3L)  sda1 sda2 sda3 sda5 sda6 sda7
 2P+1E(4L) sda1 sda2 sda5 sda6 sda7 sda8
 1P+1E(5L) sda1 sda5 sda6 sda7 sda8 sda9
 !!! 1-4为主分区，所以逻辑分区要从5开始。
 ```

 <br/>

### 磁盘分区的工作原理:
<img src="C:\Users\31650\Desktop\Python note\Oldboy\截图内容\磁盘存储逻辑图.png" alt="磁盘存储逻辑图" style="zoom:75%;" />

* 磁盘是按柱面分区的。
* 磁盘分区登记的地点: 磁盘分区表。
* 磁盘分区表是存放分区结果信息的。
* 磁盘分区表的位置: 0磁头0磁道1扇区(512字节)，占用1扇区的前446字节(系统引导信息的)后面的64字节(分区表)，剩下2个字节是分区结束标志。
* 磁盘分区表的容量是有限的，64字节，一个分区固定占16字节。64/16=4分区(主分区+扩展分区)

<br />
### 磁盘分区实战
* ==磁盘分区关键就是修改64字节的分区表而已==
##### 磁盘分区常用 fdisk
* 修改MBR分区表，MBR格式。
* 缺陷: 被修改的磁盘大小不能大于2T.

##### 磁盘分区其它命令 parted
* gpt分区格式，既能修改小于2T也能修改大于2T的磁盘。
* GUID分区表(GUID partition Table)

##### !!!建议
* 小于2T就用fdisk
* 大于2T就用parted

#### 实践
###### fdisk实践:
* first:
```
* 查看新添加的磁盘设备:
[root@redhat ~ 13:25:58]# fdisk -l

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0007a4ce

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *        2048      526335      262144   83  Linux
/dev/sda2          526336     2074623      774144   82  Linux swap / Solaris
/dev/sda3         2074624    41943039    19934208   83  Linux

[root@redhat ~ 13:31:39]# fdisk /dev/sdb   #<==开始给sdb磁盘分区
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Device does not contain a recognized partition table
Building a new DOS disklabel with disk identifier 0x8b9aa963.

Command (m for help): m  #<==查看分区的帮助信息
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition    #<==删除一个分区
   g   create a new empty GPT partition table
   G   create an IRIX (SGI) partition table
   l   list known partition types      #<==列表分区类(了解足矣)>
   m   print this menu   #<==查看分区的帮助信息
   n   add a new partition   #<==添加一个新分区
   o   create a new empty DOS partition table
   p   print the partition table    #<==查看分区结果信息
   q   quit without saving changes    #<==退出不保存
   s   create a new empty Sun disklabel
   t   change a partition's system id    #<==调整分区类型(了解足矣)
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit    #<==保存并退出
   x   extra functionality (experts only)


```
* second: 3P+1E(3L)
```
* 3P+1E(3L)  sda1 sda2 sda3 sda5 sda6 sda7
Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 
First sector (2048-2097151, default 2048): 
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-2097151, default 2097151): +150M
Partition 1 of type Linux and of size 150 MiB is set

Command (m for help): n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): p
Partition number (2-4, default 2): 
First sector (309248-2097151, default 309248): 
Using default value 309248
Last sector, +sectors or +size{K,M,G} (309248-2097151, default 2097151): +150M
Partition 2 of type Linux and of size 150 MiB is set

Command (m for help): n
Partition type:
   p   primary (2 primary, 0 extended, 2 free)
   e   extended
Select (default p): p
Partition number (3,4, default 3): 
First sector (616448-2097151, default 616448): 
Using default value 616448
Last sector, +sectors or +size{K,M,G} (616448-2097151, default 2097151): +150M
Partition 3 of type Linux and of size 150 MiB is set

Command (m for help): P

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x8b9aa963

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048      309247      153600   83  Linux
/dev/sdb2          309248      616447      153600   83  Linux
/dev/sdb3          616448      923647      153600   83  Linux

Command (m for help): N
Partition type:
   p   primary (3 primary, 0 extended, 1 free)
   e   extended
Select (default e): p
Selected partition 4
First sector (923648-2097151, default 923648): 
Using default value 923648
Last sector, +sectors or +size{K,M,G} (923648-2097151, default 2097151): +150M    
Partition 4 of type Linux and of size 150 MiB is set

Command (m for help): P

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x8b9aa963

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048      309247      153600   83  Linux
/dev/sdb2          309248      616447      153600   83  Linux
/dev/sdb3          616448      923647      153600   83  Linux
/dev/sdb4          923648     1230847      153600   83  Linux

Command (m for help): n
If you want to create more than four partitions, you must replace a
primary partition with an extended partition first.

Command (m for help): d
Partition number (1-4, default 4): 4
Partition 4 is deleted

Command (m for help): p      

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x8b9aa963

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048      309247      153600   83  Linux
/dev/sdb2          309248      616447      153600   83  Linux
/dev/sdb3          616448      923647      153600   83  Linux

Command (m for help): n
Partition type:
   p   primary (3 primary, 0 extended, 1 free)
   e   extended
Select (default e): e
Selected partition 4
First sector (923648-2097151, default 923648): 
Using default value 923648
Last sector, +sectors or +size{K,M,G} (923648-2097151, default 2097151): 
Using default value 2097151
Partition 4 of type Extended and of size 573 MiB is set


Command (m for help): n
All primary partitions are in use
Adding logical partition 5
First sector (925696-2097151, default 925696): 
Using default value 925696
Last sector, +sectors or +size{K,M,G} (925696-2097151, default 2097151): +150M
Partition 5 of type Linux and of size 150 MiB is set

Command (m for help): N
All primary partitions are in use
Adding logical partition 6
First sector (1234944-2097151, default 1234944): 
Using default value 1234944
Last sector, +sectors or +size{K,M,G} (1234944-2097151, default 2097151): +150M
Partition 6 of type Linux and of size 150 MiB is set

Command (m for help): N
All primary partitions are in use
Adding logical partition 7
First sector (1544192-2097151, default 1544192): 
Using default value 1544192
Last sector, +sectors or +size{K,M,G} (1544192-2097151, default 2097151): +150M
Partition 7 of type Linux and of size 150 MiB is set

Command (m for help): p

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x8b9aa963

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048      309247      153600   83  Linux
/dev/sdb2          309248      616447      153600   83  Linux
/dev/sdb3          616448      923647      153600   83  Linux
/dev/sdb4          923648     2097151      586752    5  Extended
/dev/sdb5          925696     1232895      153600   83  Linux
/dev/sdb6         1234944     1542143      153600   83  Linux
/dev/sdb7         1544192     1851391      153600   83  Linux


[oldboy@redhat ~]$ sudo ls -l /dev/sd*
brw-rw---- 1 root disk 8,  0 Oct  9 13:54 /dev/sda
brw-rw---- 1 root disk 8,  1 Oct  9 13:54 /dev/sda1
brw-rw---- 1 root disk 8,  2 Oct  9 13:54 /dev/sda2
brw-rw---- 1 root disk 8,  3 Oct  9 13:54 /dev/sda3
brw-rw---- 1 root disk 8, 16 Oct  9 14:10 /dev/sdb
brw-rw---- 1 root disk 8, 17 Oct  9 14:10 /dev/sdb1
brw-rw---- 1 root disk 8, 18 Oct  9 14:10 /dev/sdb2
brw-rw---- 1 root disk 8, 19 Oct  9 14:10 /dev/sdb3
brw-rw---- 1 root disk 8, 20 Oct  9 14:10 /dev/sdb4
brw-rw---- 1 root disk 8, 21 Oct  9 14:10 /dev/sdb5
brw-rw---- 1 root disk 8, 22 Oct  9 14:10 /dev/sdb6
brw-rw---- 1 root disk 8, 23 Oct  9 14:10 /dev/sdb7

!!! 要想用LVM，分区类型就要是LVM的，按t进行更改。
```

###### parted实践:
* 例子:
```
需求：RAID 5大小6T，已经装了系统了，额外添加4块2T盘。
现有一个做了RAID 5的硬盘，要求分三个区，
硬盘总分区大小:      6.2T
/data0               4.8T
/data1               1T
                     4G(无需格式化，做DRBD+Hearbeat+MySQL高可用集群)
parted /dev/sdb mklable gpt                     #<==修改分区格式为gpt
parted /dev/sdb mkpart primary 0 4800000        #<==创建一个4.8T主分区
parted /dev/sdb mkpart primary 4800001 5800001  #<==创建一个1T主分区
parted /dev/sdb mkpart primary 5800002 5804098  #<==创建一个4G主分区
parted /dev/sdb p                               #<==打印分区
```
* 实践过程:
```
[root@redhat ~ 19:29:38]# parted /dev/sdb
GNU Parted 3.1
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.

(parted) mklabel gpt                       #<==将分区类型从msdos改为gpt                              
Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk
will be lost. Do you want to continue?
Yes/No? yes                       #<==确认更改                                                            

(parted) mkpart primary 0 480             #<==创建480M的主分区                                
Warning: The resulting partition is not properly aligned for best performance.
Ignore/Cancel? ignore           #<==忽略提示                                             
                                          
(parted) mkpart logic 581 600            #<==创建20M的逻辑分区                                  
(parted) p                                                                
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 1074MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End    Size    File system  Name     Flags
 1      17.4kB  480MB  480MB                primary
 2      481MB   580MB  98.6MB               primary
 3      581MB   600MB  18.9MB               logic

(parted) q                                                                
Information: You may need to update /etc/fstab.

[root@redhat ~ 19:33:35]# ls -l /dev/sdb*                                 
brw-rw---- 1 root disk 8, 16 Oct  9 19:33 /dev/sdb
brw-rw---- 1 root disk 8, 17 Oct  9 19:33 /dev/sdb1
brw-rw---- 1 root disk 8, 18 Oct  9 19:33 /dev/sdb2
brw-rw---- 1 root disk 8, 19 Oct  9 19:33 /dev/sdb3
[root@redhat ~ 19:33:43]# parted /dev/sdb
GNU Parted 3.1
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) rm 3            #<==删除第3分区                                                      
(parted) p                                                                
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 1074MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End    Size    File system  Name     Flags
 1      17.4kB  480MB  480MB                primary
 2      481MB   580MB  98.6MB               primary

(parted) mkpart logic 581 600                                             
(parted) p                                                                
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 1074MB
Sector size (logical/physical): 512B/512B
Partition Table: gpt
Disk Flags: 

Number  Start   End    Size    File system  Name     Flags
 1      17.4kB  480MB  480MB                primary
 2      481MB   580MB  98.6MB               primary
 3      581MB   600MB  18.9MB               logic

```

#### 命令
* fdisk   磁盘分区工具(MBR)
    + -l   查看分区列表
        - cat /proc/partitions (查看分区)
    + /dev/sdb   开始给sdb磁盘分区
    + fdisk 只能root权限用户使用
    + fdisk 适合于对装系统后的剩余空间进行分区，例如:安装系统时没有全部分区，或者安装系统后添加新磁盘。

!!! 分区完后一定要执行pratprobe + 分区
* partprobe /dev/sdb   将分区信息通知内核，真正生效。


* parted   磁盘分区工具(GPT)
    + mklabel gpt
    + mkpart primary 0 480
    + mkpart logic 481 600
    + rm 4


* dd if=/dev/sda of=/dev/sdb bs=512 count=10240
    + if：来源     of：生成的文件系统   bs：block大小  count：块个数

#### 磁盘==买房
```
磁盘：      买房
RAID：      多套房子大通
分区：      隔断/几居室
==================================
文件系统：  装修风格
格式化过程：装修的过程
挂载：      开门住人，使用
磁盘管理：  生活收拾屋子，打扫卫生。
```


#### 作业问题:
* 如何用一条fdisk命令回车完成上述分区。

* 如何用一条parted命令回车完成上述分区。
```
parted /dev/sdb mklable gpt                     
parted /dev/sdb mkpart primary 0 480
ignore        
parted /dev/sdb mkpart primary 481 581
parted /dev/sdb mkpart logic 582 600
parted /dev/sdb p                               
```
* 问题需求: 刚买的服务器 4块2T 刚买，要做RAID 5,装系统怎么搞定？
```
方法1: Raid里可以支持RAID 5后，6T，允许你把6T分成虚拟磁盘。
      200G分成第一个虚拟磁盘剩下不分留着装系统后(parted)。
方法2: 装系统，系统镜像支持GPT格式分区，很隐蔽。
方法3: 引导工具，进入然后用parted分区。
```



<br />

## 文件系统
##### 什么是文件系统？
* 计算机存储和组织数据的方法或者机制。
##### 为什么需要文件系统？
* 磁盘、物理介质、磁粒子物理元素。硬件需要软件驱动使用，磁盘需要文件系统驱动。
* 文件系统实现通过磁盘管理规划、存取数据。
##### 文件系统有那些种类？
* Windows: NTFS、Fat32、msdos
* Linux: ext2、ext3(CentOS-5)、ext4(CentOS-6)、xfs(CentOS-7)、btrfs
#### 创建文件系统实践
* 修改分区格式:
```
[root@redhat ~ 21:09:14]# parted /dev/sdb
GNU Parted 3.1
Using /dev/sdb
Welcome to GNU Parted! Type 'help' to view a list of commands.
(parted) mklabel msdos                                                    
Warning: The existing disk label on /dev/sdb will be destroyed and all data on this disk
will be lost. Do you want to continue?
Yes/No? yes                                                               
(parted) p                                                                
Model: VMware, VMware Virtual S (scsi)
Disk /dev/sdb: 1074MB
Sector size (logical/physical): 512B/512B
Partition Table: msdos
Disk Flags: 

Number  Start  End  Size  Type  File system  Flags

(parted) q                                                                
Information: You may need to update /etc/fstab.

```
* fdisk 分两区
```
[root@redhat ~ 21:09:55]# fdisk /dev/sdb
Welcome to fdisk (util-linux 2.23.2).

Changes will remain in memory only, until you decide to write them.
Be careful before using the write command.

Command (m for help): n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
Partition number (1-4, default 1): 
First sector (2048-2097151, default 2048): 
Using default value 2048
Last sector, +sectors or +size{K,M,G} (2048-2097151, default 2097151): +100M
Partition 1 of type Linux and of size 100 MiB is set

Command (m for help): n
Partition type:
   p   primary (1 primary, 0 extended, 3 free)
   e   extended
Select (default p): p
Partition number (2-4, default 2): 
First sector (206848-2097151, default 206848): 
Using default value 206848
Last sector, +sectors or +size{K,M,G} (206848-2097151, default 2097151): +100M
Partition 2 of type Linux and of size 100 MiB is set

Command (m for help): p

Disk /dev/sdb: 1073 MB, 1073741824 bytes, 2097152 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk label type: dos
Disk identifier: 0x0005af33

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048      206847      102400   83  Linux
/dev/sdb2          206848      411647      102400   83  Linux

Command (m for help): w

```

* 格式化ext4文件系统其实关键就是生成一定数量的Inode和Block。
   + 等价于mkfs.ext4
```
[root@redhat ~ 21:14:47]# mkfs -t ext4 /dev/sdb1
mke2fs 1.42.9 (28-Dec-2013)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
25688 inodes, 102400 blocks
5120 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=33685504
13 block groups
8192 blocks per group, 8192 fragments per group
1976 inodes per group
Superblock backups stored on blocks: 
	8193, 24577, 40961, 57345, 73729

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done
```
* 挂载到/mnt
```
[root@redhat ~ 21:15:08]# mount -t ext4 /dev/sdb1 /mnt
[root@redhat ~ 21:19:51]# df -h   #<==查看挂载结
Filesystem      Size  Used Avail Use% Mounted on
devtmpfs        900M     0  900M   0% /dev
tmpfs           910M     0  910M   0% /dev/shm
tmpfs           910M  9.6M  901M   2% /run
tmpfs           910M     0  910M   0% /sys/fs/cgroup
/dev/sda3        20G  2.2G   17G  12% /
/dev/sda1       253M  162M   92M  64% /boot
tmpfs           182M     0  182M   0% /run/user/1001
/dev/sdb1        93M  1.6M   85M   2% /mnt   #<==已挂载
[root@redhat ~ 21:19:53]# cat /proc/mounts
```

#### 文件系统原理(ext文件系统)、文件系统特点

#### 企业中如何选择文件系统

#### 企业里如何优化文件系统？











